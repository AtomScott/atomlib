# AUTOGENERATED! DO NOT EDIT! File to edit: 01_cp.ipynb (unless otherwise specified).

__all__ = ['binomial_coefficients', 'memo', 'multinomial_coefficients', 'multinomial_combinations', 'memo']

# Cell
from .utils import timing
from itertools import *

# Cell
memo = {}
def binomial_coefficients(n:int, k:int)->int:
    # base case 1
    if k == 0:
        return 1
    # base case 2
    if n == 0:
        return 0
    # Check memo
    if not memo.get((n,k), False):
        # Add result to memo
        memo[(n,k)] = int(n / k * binomial_coefficients(n-1, k-1))
    return memo[(n,k)]

# Cell
memo = {}
def multinomial_coefficients(K: list) -> int:
    """
    Returns the multinomial coefficients

    - `K` - A list of [$k_1, k_2...$]
    """
    # Memoization method
    # A direct implementation of the binomial representation
    # Better for smaller numbers
#     m = 1
#     for i in range(1, len(K)+1):
#         m  *= binomial_coefficients(sum(K[:i]), K[i-1])

    # Iterative method
    res, i = 1, sum(K)
    i0 = K.index(max(K))
    for a in K[:i0] + K[i0+1:]:
        for j in range(1,a+1):
            res = (res * i) // j
            i -= 1
    return res

def multinomial_combinations(items):
    pool = tuple(items)
    n_items = len(pool)

    if len(ks) == 1:
        for c in itertools.combinations(items, ks[0]):
            yield (c,)

    else:
      for c_first in itertools.combinations(items, ks[0]):
         items_remaining= sorted(set(items) - set(c_first))

         for c_other in _m_way_ordered_combinations(items_remaining, ks[1:]):
             yield (c_first,) + c_other
